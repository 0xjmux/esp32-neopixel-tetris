/**
 * Test code for ingesting messages from the Wizmote ESP-NOW remote
*/

// this include block copied from espnow_example_main.c
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <assert.h>
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include "freertos/timers.h"
#include "nvs_flash.h"
#include "esp_random.h"
#include "esp_event.h"
#include "esp_netif.h"
#include "esp_wifi.h"
#include "esp_log.h"
#include "esp_mac.h"
#include "esp_now.h"
#include "esp_crc.h"

#include "espnow_remote_test.h"
// #include "espnow_example.h"

////////////////////////////////////////
// TEMPORARY DEFS
// real impl needs to be able to find and accept any local remote, not just mine
#define MY_REMOTE_MAC 0x444f8ebf15
#define ESPNOW_WIFI_MODE WIFI_MODE_STA

static uint8_t s_example_broadcast_mac[ESP_NOW_ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
// static uint16_t s_example_espnow_seq[EXAMPLE_ESPNOW_DATA_MAX] = { 0, 0 };

////////////////////////////////////////

static const char *TAG = "espnow_wizmote_example";

static uint32_t last_msg_seq = UINT32_MAX;      // seq number of last message
static espnow_msg_structure incoming;           // holds incoming message data
static QueueHandle_t s_example_espnow_queue;    // semaphore for espnow handling

/* WiFi should start before using ESPNOW */
static void example_wifi_init(void)
{
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK( esp_wifi_init(&cfg) );
    ESP_ERROR_CHECK( esp_wifi_set_storage(WIFI_STORAGE_RAM) );
    ESP_ERROR_CHECK( esp_wifi_set_mode(ESPNOW_WIFI_MODE) );
    ESP_ERROR_CHECK( esp_wifi_start());
    ESP_ERROR_CHECK( esp_wifi_set_channel(CONFIG_ESPNOW_CHANNEL, WIFI_SECOND_CHAN_NONE));

#if CONFIG_ESPNOW_ENABLE_LONG_RANGE
    ESP_ERROR_CHECK( esp_wifi_set_protocol(ESPNOW_WIFI_IF, WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_LR) );
#endif
}


// typedef void (*esp_now_recv_cb_t)(const esp_now_recv_info_t * esp_now_info, const uint8_t *data, int data_len);
static void on_data_recv(const uint8_t *mac_addr, const uint8_t *in_data, size_t len) {
    // char last_packet_src[STR_MAX_LEN];
    // parse packet addr and log data to console
    sprintf(last_signal_src, "%02x%02x%02x%02x%02x%02x", \
        mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
    
    ESP_LOGI(TAG, "ESP-NOW message received from addr: %s", last_signal_src);
    
    if (len != sizeof(incoming)) {
        ESP_LOGI(TAG, "Incorrect len - was expecting sizeof(incoming)=%d, but incoming len=%d\n", \
            sizeof(incoming), len);
        // return???
    }

    memcpy(&(incoming.program), in_data, sizeof(incoming));
    
    // WTF is this
    uint32_t cur_seq = incoming.seq[0] | (incoming.seq[1] << 8) | (incoming.seq[2] << 16) | (incoming.seq[3] << 24);
    
    // dont parse same packet twice
    if (cur_seq == last_msg_seq) {
        return;
    }

    ESP_LOGI(TAG, "Incoming ESP-NOW Packet [SEQ=%d, Sender = %s, button=%d] \n", cur_seq, last_signal_src, incoming.button);


    // switch case logic goes here

    last_msg_seq = cur_seq;
}

// FROM EXAMPLE
static void example_espnow_recv_cb(const esp_now_recv_info_t *recv_info, const uint8_t *data, int len)
{
    // example_espnow_event_t evt;
    example_espnow_event_recv_cb_t recv_cb; 
    uint8_t * mac_addr = recv_info->src_addr;

    if (mac_addr == NULL || data == NULL || len <= 0) {
        ESP_LOGE(TAG, "Receive cb arg error");
        return;
    }

    recv_cb.id = EXAMPLE_ESPNOW_RECV_CB;
    memcpy(recv_cb.mac_addr, mac_addr, ESP_NOW_ETH_ALEN);
    recv_cb.data = malloc(len);
    if (recv_cb.data == NULL) {
        ESP_LOGE(TAG, "Malloc receive data fail");
        return;
    }
    memcpy(recv_cb.data, data, len);
    recv_cb.data_len = len;
    if (xQueueSend(s_example_espnow_queue, &recv_cb, ESPNOW_MAXDELAY) != pdTRUE) {
        ESP_LOGW(TAG, "Send receive queue fail");
        free(recv_cb.data);
    }
}

// FROM EXAMPLE
/* Parse received ESPNOW data. */
uint8_t example_espnow_data_parse(uint8_t *data, uint16_t data_len, uint8_t *program, \
    uint8_t *seq[4], uint8_t *button)
{
    espnow_msg_structure *buf = (espnow_msg_structure *)data;
    // uint16_t crc, crc_cal = 0;

    if (data_len < sizeof(espnow_msg_structure)) {
        ESP_LOGE(TAG, "Receive ESPNOW data too short, len:%d", data_len);
        // return -1;
    }

    *program = buf->program;
    *seq = buf->seq;
    *button = buf->button;

    // parse all
    
    // if (*program == )

    // *state = buf->state;
    // *magic = buf->magic;
    // crc = buf->crc;
    // buf->crc = 0;
    // crc_cal = esp_crc16_le(UINT16_MAX, (uint8_t const *)buf, data_len);

    // return -1;
    return 0;
}

// a lot of this copied from espnow_example_main.c
static esp_err_t espnow_remote_recv_init(void) {
 
    s_example_espnow_queue = xQueueCreate(ESPNOW_QUEUE_SIZE, sizeof(example_espnow_event_recv_cb_t));
    if (s_example_espnow_queue == NULL) {
        ESP_LOGE(TAG, "Create mutex fail");
        return ESP_FAIL;
    }    
    
    ESP_ERROR_CHECK(esp_now_init()); // must be called to set up ESP-NOW, but after wifi

    // ESP_ERROR_CHECK( esp_now_register_recv_cb(example_espnow_recv_cb) );
    ESP_ERROR_CHECK( esp_now_register_recv_cb(on_data_recv) );

    /* Set primary master key. (not used in my sketch )*/
    ESP_ERROR_CHECK( esp_now_set_pmk((uint8_t *)CONFIG_ESPNOW_PMK) );

    /* Add broadcast peer information to peer list. */
    esp_now_peer_info_t *peer = malloc(sizeof(esp_now_peer_info_t));
    if (peer == NULL) {
        ESP_LOGE(TAG, "Malloc peer information fail");
        vSemaphoreDelete(s_example_espnow_queue);
        esp_now_deinit();
        return ESP_FAIL;
    }
    memset(peer, 0, sizeof(esp_now_peer_info_t));
    peer->channel = CONFIG_ESPNOW_CHANNEL;
    peer->ifidx = ESPNOW_WIFI_IF;
    peer->encrypt = false;
    memcpy(peer->peer_addr, s_example_broadcast_mac, ESP_NOW_ETH_ALEN);
    ESP_ERROR_CHECK( esp_now_add_peer(peer) );
    free(peer);

    return ESP_OK;
}

void espnow_remote_recv_teardown(void) {
    vSemaphoreDelete(s_example_espnow_queue);
    ESP_ERROR_CHECK(esp_now_deinit());
}


/**
 * FreeRTOS task to handle data reception
*/
static void espnow_recv_task(void *pvParameter)
{
    // example_espnow_event_t evt;
    uint8_t recv_state = 0;
    uint16_t recv_seq = 0;
    int recv_magic = 0;
    bool is_broadcast = false;
    int ret;

    vTaskDelay(5000 / portTICK_PERIOD_MS);

    while (xQueueReceive(s_example_espnow_queue, &evt, portMAX_DELAY) == pdTRUE) {
        example_espnow_event_recv_cb_t *recv_cb = &evt.info.recv_cb;

        ret = example_espnow_data_parse(recv_cb->data, recv_cb->data_len, &recv_state, &recv_seq, &recv_magic);
        free(recv_cb->data);
        if (ret == EXAMPLE_ESPNOW_DATA_BROADCAST) {
            ESP_LOGI(TAG, "Receive %dth broadcast data from: "MACSTR", len: %d", recv_seq, MAC2STR(recv_cb->mac_addr), recv_cb->data_len);

            /* If MAC address does not exist in peer list, add it to peer list. */
            if (esp_now_is_peer_exist(recv_cb->mac_addr) == false) {
                esp_now_peer_info_t *peer = malloc(sizeof(esp_now_peer_info_t));
                if (peer == NULL) {
                    ESP_LOGE(TAG, "Malloc peer information fail");
                    example_espnow_deinit(send_param);
                    vTaskDelete(NULL);
                }
                memset(peer, 0, sizeof(esp_now_peer_info_t));
                peer->channel = CONFIG_ESPNOW_CHANNEL;
                peer->ifidx = ESPNOW_WIFI_IF;
                peer->encrypt = true;
                memcpy(peer->lmk, CONFIG_ESPNOW_LMK, ESP_NOW_KEY_LEN);
                memcpy(peer->peer_addr, recv_cb->mac_addr, ESP_NOW_ETH_ALEN);
                ESP_ERROR_CHECK( esp_now_add_peer(peer) );
                free(peer);
            }

            /* Indicates that the device has received broadcast ESPNOW data. */
            if (send_param->state == 0) {
                send_param->state = 1;
            }

            /* If receive broadcast ESPNOW data which indicates that the other device has received
                * broadcast ESPNOW data and the local magic number is bigger than that in the received
                * broadcast ESPNOW data, stop sending broadcast ESPNOW data and start sending unicast
                * ESPNOW data.
                */
            if (recv_state == 1) {
                /* The device which has the bigger magic number sends ESPNOW data, the other one
                    * receives ESPNOW data.
                    */
                if (send_param->unicast == false && send_param->magic >= recv_magic) {
                    ESP_LOGI(TAG, "Start sending unicast data");
                    ESP_LOGI(TAG, "send data to "MACSTR"", MAC2STR(recv_cb->mac_addr));

                    /* Start sending unicast ESPNOW data. */
                    memcpy(send_param->dest_mac, recv_cb->mac_addr, ESP_NOW_ETH_ALEN);
                    example_espnow_data_prepare(send_param);
                    if (esp_now_send(send_param->dest_mac, send_param->buffer, send_param->len) != ESP_OK) {
                        ESP_LOGE(TAG, "Send error");
                        example_espnow_deinit(send_param);
                        vTaskDelete(NULL);
                    }
                    else {
                        send_param->broadcast = false;
                        send_param->unicast = true;
                    }
                }
            }
        }
        else if (ret == EXAMPLE_ESPNOW_DATA_UNICAST) {
            ESP_LOGI(TAG, "Receive %dth unicast data from: "MACSTR", len: %d", recv_seq, MAC2STR(recv_cb->mac_addr), recv_cb->data_len);

        }
        else {
            ESP_LOGI(TAG, "Receive error data from: "MACSTR"", MAC2STR(recv_cb->mac_addr));
        }
        break;
    }

}


void app_main(void)
{
    // Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK( nvs_flash_erase() );
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK( ret );

    example_wifi_init();
    // set up esp-now functionality
    espnow_remote_recv_init();

    // espnow_remote_teardown();
    // once main exits it should go on forever via tasks

}

